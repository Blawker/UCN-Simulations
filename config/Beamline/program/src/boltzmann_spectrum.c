#include "TCanvas.h"
#include "TFrame.h"
#include "TBenchmark.h"
#include "TString.h"
#include "TF1.h"
#include "TH1.h"
#include "TFile.h"
#include "TROOT.h"
#include "TError.h"
#include "TInterpreter.h"
#include "TSystem.h"
#include "TPaveText.h"




void BoltzmannDist_GUI() {
  // Create the Boltzmann Distribution function for the Simulation
  const Double_t k = 1.38e-23;
  Double_t T = 30; // Temperature in K
  const Double_t e = 1.602e-19;
  Double_t upper_energy = 1.e-2; // in eV
  Double_t lower_energy = 1.e-9; // in eV
  const Int_t n = 100;
  TF1 boltz_dist("boltzmann distribution",
                  "TMath::Power(2*TMath::Sqrt(x/TMath::Pi())*(1/[0]), 3/2) * exp(-x/[0])",
                  lower_energy,upper_energy);
  boltz_dist.SetParameter(0, k*T/e);
  // Create a histogram, fill it with random gaussian numbers
  TH1F *histogram_1 = new TH1F ("histogram_1", "Boltzmann Distribution histogram",
                                n, lower_energy,upper_energy);
  //histogram_1->FillRandom("gaus",1000);
  for (int i=0;i<100000000;i++) {
    histogram_1->Fill(boltz_dist.GetRandom());
  }

  /*ouble_t x, y;
  for (Int_t i=0; i<n; i++) {
    x = lower_energy + i*(upper_energy-lower_energy)/n;
    y = boltz_dist(x);
    printf("%e %e\n", x, y);
    histogram_1->Fill(y);
  }*/
  auto canvas_1 = new TCanvas();
  // draw the histogram
  histogram_1->DrawClone();
  /* - Create a new ROOT file for output
  - Note that this file may contain any kind of ROOT objects, histograms,
  pictures, graphics objects etc.
  - the new file is now becoming the current directory */
  TFile *file_1 = new TFile("boltzmann_spectrum.root","RECREATE","boltzmann_spectrum");
  // write Histogram to current directory (i.e. the file just opened)
  histogram_1->Write();
  // Close the file.
  // (You may inspect your histogram in the file using the TBrowser class)
  file_1->Close();
  canvas_1->Draw();
}



Double_t fit_function(Double_t *x, Double_t *par) {
  // Fit with a Maxwell-Boltzmann distribution; Parameters[0: temperature T, 1: Normalized Constant]
  Double_t k = 1.38e-23; // Boltzmann constant
  Double_t e = 1.602e-19; // Coulomb charge in J
  Double_t T = 2.e-3; // Temperature in K
  Double_t fitval = par[0]*TMath::Power(2*TMath::Sqrt(x[0]*e/TMath::Pi())*(1/(k*T)), 3/2) * exp(-x[0]*e/(k*T));
  return(fitval);
}

void simulation_extraction() {
  // https://root.cern.ch/root/html/tutorials/tree/tree1.C.html

  Double_t k = 1.38e-23; // Boltzmann constant
  Double_t T = 30; // Temperature in K
  Double_t e = 1.602e-19; // Coulomb charge in J
  Double_t upper_energy = 200.e-9; // in eV
  Double_t lower_energy = 1.e-11; // in eV

  TCanvas *canvas_1 = new TCanvas("c1", "Boltzmann Distribution");

  //read the Tree generated by tree1w and fill two histograms

  //note that we use "new" to create the TFile and TTree objects !
  //because we want to keep these objects alive when we leave this function.
  TFile *f = new TFile("../../../output/Beamline/beamline_simulation_P1.root");
  TTree *t1 = (TTree*)f->Get("component_step_P1_DATA");
  Double_t ke;
  t1->SetBranchAddress("kinetic_energy",&ke);

  //create one histogram
  TH1F *hke = new TH1F("hke_P1", "Kinetic Energy Distribution", 100, lower_energy, upper_energy);

  //read all entries and fill the histograms
  Long64_t n_entries = t1->GetEntries();
  for (Long64_t i=0; i<n_entries; i++) {
    t1->GetEntry(i);
    hke->Fill(ke);
  }
  hke->DrawClone();

  /* - Create a new ROOT file for output
  - Note that this file may contain any kind of ROOT objects, histograms,
  pictures, graphics objects etc.
  - the new file is now becoming the current directory */
  TFile *file_1 = new TFile("../histogram/beamline_spectrum_P1.root","RECREATE","boltzmann_spectrum");
  // write Histogram to current directory (i.e. the file just opened)
  hke->Write();
  // Close the file.
  // (You may inspect your histogram in the file using the TBrowser class)
  file_1->Close();
  //canvas_1->Draw();

  // Fit
  /*TF1 *func = new TF1("fit",fit_function, lower_energy, upper_energy, 1);
  func->SetParameters(0, 50);
  //func->SetParameters(1, 1);
  func->SetParNames("Normalized Const");
  hke->Fit(func, "R");*/
  //hke->DrawClone();

  // Results
  /*TF1 *fit = hke->GetFunction("fit");
  Double_t temperature_fit = fit->GetParameter(0);
  func->Draw("same");
  printf("beta : %e , T = %e\n", k*temperature_fit, temperature_fit);
  */

  //canvas_1->Draw();

  //we do not close the file. We want to keep the generated histograms
  //we open a browser and the TreeViewer
  /*
  if (gROOT->IsBatch()) return;
  new TBrowser();
  t1->StartViewer();
  */
  // in the browser, click on "ROOT Files", then on "tree1.root".
  //     you can click on the histogram icons in the right panel to draw them.
  // in the TreeViewer, follow the instructions in the Help button.
}


void BoltzmannDistTheorical_GUI() {
  Double_t k = 1.38e-23;
  Double_t T = 0.003; // Temperature in K
  Double_t e = 1.602e-19;
  Double_t upper_energy = 1.e-6; // in J
  Double_t lower_energy = 1.e-11; // in J
  TF1 BoltzDist("Boltzmann_Distribution_Theory","2*TMath::Sqrt(x/TMath::Pi())*(1/[0])^(3/2)*exp(-x/[0])",lower_energy,upper_energy);
  BoltzDist.SetParameter(0, k*T/e);

  TCanvas *canvas_1 = new TCanvas("c1", "Boltzmann Distribution Theory");

  const Int_t n = 100;
  Double_t x[n], y[n];
  for (Int_t i=0; i<n; i++) {
    x[i] = lower_energy + i*(upper_energy-lower_energy)/n;
    y[i] = BoltzDist(x[i]);
  }
  TGraph *gr = new TGraph(n, x, y);
  gr->SetTitle("Boltzmann Distribution Theory");
  gr->SetLineColor(2);
  gr->Draw();

  //canvas_1->Update();

  /*TFile *file_1 = new TFile("boltzmann_distribution_theory.root", "RECREATE", "boltzmann_distribution_theory");
  gr->Write();
  file_1->Close();

  auto canvas_1 = TCanvas();
  BoltzDist.DrawClone();*/

  //TFile *file_1 = new TFile("boltzmann_distribution_theory.root", "RECREATE", "boltzmann_distribution_theory");
  //canvas_1.Write();
  //file_1->Close();
  //canvas_1->Draw();
}
/*
void graph() {
   //Draw a simple graph
   // To see the output of this macro, click begin_html <a href="gif/graph.gif">here</a>. end_html
   //Author: Rene Brun

   TCanvas *c1 = new TCanvas("c1","A Simple Graph Example",200,10,700,500);

   c1->SetFillColor(42);
   c1->SetGrid();

   const Int_t n = 20;
   Double_t x[n], y[n];
   for (Int_t i=0;i<n;i++) {
     x[i] = i*0.1;
     y[i] = 10*sin(x[i]+0.2);
     printf(" i %i %f %f \n",i,x[i],y[i]);
   }
   TGraph *gr = new TGraph(n,x,y);
   gr->SetLineColor(2);
   gr->SetLineWidth(4);
   gr->SetMarkerColor(4);
   gr->SetMarkerStyle(21);
   gr->SetTitle("a simple graph");
   gr->GetXaxis()->SetTitle("X title");
   gr->GetYaxis()->SetTitle("Y title");
   gr->Draw("ACP");

   // TCanvas::Update() draws the frame, after which one can change it
   c1->Update();
   c1->GetFrame()->SetFillColor(21);
   c1->GetFrame()->SetBorderSize(12);
   c1->Modified();
}
*/
